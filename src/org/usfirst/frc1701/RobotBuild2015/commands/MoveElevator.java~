// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1701.RobotBuild2015.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1701.RobotBuild2015.Robot;
import org.usfirst.frc1701.RobotBuild2015.RobotMap;

/**
 *
 */
public class  MoveElevator extends Command {

	
    public MoveElevator() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.elevator);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	double y = Robot.oi.getElevatorJoystick().getY()*0.67;
    	double x = Robot.oi.getElevatorJoystick().getX();
//    	if(q != lastq){
//	    	if(q < -0.75){
//	    		new ElevatortoBottom().start();
//	    	}else if(q > 0.75){
//	    		new ElevatortoTop().start();
//	    	}else{
//	    		new ElevatortoOneTote().start();
//	    	}
//    	}
    	RobotMap.last = RobotMap.elevatorOneToteLimitSwitch.get();
    	SmartDashboard.putBoolean("bottom limit", RobotMap.elevatorBottomLimitSwitch.get());
    	SmartDashboard.putBoolean("top limit", RobotMap.elevatorTopLimitSwitch.get());
    	SmartDashboard.putBoolean("step limit", RobotMap.elevatorStepLimitSwitch.get());
    	SmartDashboard.putBoolean("tote limit", RobotMap.elevatorOneToteLimitSwitch.get());
    	/*SmartDashboard.putBoolean("tote limit", RobotMap.last);
    	SmartDashboard.putBoolean("left retract limit", RobotMap.elevatorLeftSlideLimitSwitchRetracted.get());
    	SmartDashboard.putBoolean("right retract limit", RobotMap.elevatorRightSlideLimitSwitchRetracted.get());
    	SmartDashboard.putBoolean("hold tote limit", RobotMap.elevatorRightSlideLimitSwitchTote.get());
    	SmartDashboard.putBoolean("extend limit", RobotMap.elevatorRightSlideLimitSwitchExtended.get());*/
    	SmartDashboard.putBoolean("ir thing", RobotMap.elevatorIRToteIn.get());
    	if(RobotMap.elevatorBottomLimitSwitch.get() && y >0){
    		RobotMap.elevatorElevatorMotorL.set(0);
    		RobotMap.elevatorElevatorMotorR.set(0);
    	}else if(RobotMap.elevatorTopLimitSwitch.get() && y <0){
    		RobotMap.elevatorElevatorMotorL.set(0);
    		RobotMap.elevatorElevatorMotorR.set(0);
    	}else if(Math.abs(y) > 0.15){
    		RobotMap.elevatorElevatorMotorL.set(y);
    		RobotMap.elevatorElevatorMotorR.set(y);
    	}else{
    		RobotMap.elevatorElevatorMotorL.set(0);
    		RobotMap.elevatorElevatorMotorR.set(0);
    	}
//    	if(x > 0 && (RobotMap.elevatorLeftSlideLimitSwitchRetracted.get() || RobotMap.elevatorRightSlideLimitSwitchRetracted.get())){
//    		RobotMap.elevatorExtendMotorL.set(0);
//    		RobotMap.elevatorExtendMotorR.set(0);
//    	}else{
    		if(Math.abs(x) > 0.90){
        		RobotMap.elevatorExtendMotorL.set(-x);
        		RobotMap.elevatorExtendMotorR.set(x);
        	}else{
        		RobotMap.elevatorExtendMotorL.set(0);
        		RobotMap.elevatorExtendMotorR.set(0);
        	}
//    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
