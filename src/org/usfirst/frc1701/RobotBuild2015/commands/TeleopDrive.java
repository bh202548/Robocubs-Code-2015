// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1701.RobotBuild2015.commands;

import org.usfirst.frc1701.RobotBuild2015.OI;
import org.usfirst.frc1701.RobotBuild2015.Robot;
import org.usfirst.frc1701.RobotBuild2015.RobotMap;
import org.usfirst.frc1701.helperfiles.Vector;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class TeleopDrive extends Command {

	private final int OFFSETSTEERENCODERFL = 0;
	private final int OFFSETSTEERENCODERFR = 0;
	private final int OFFSETSTEERENCODERBR = 0;
	private final int OFFSETSTEERENCODERBL = 0;
	private final double STEERSPEEDCOEFFICIENT = 1.0/180.0;
	private Vector wheelFL, wheelFR, wheelBR, wheelBL, driveStick;
	private boolean inverseFL, inverseFR, inverseBL, inverseBR;
	private double deadzone = 0.15;
	private double driveX = 0;
	private double driveY = 0;
	private double rotateX = 0;
	private double angleFL = 0;
	private double angleFR = 0;
	private double angleBR = 0;
	private double angleBL = 0;
	private double steerSpeedFL = 0;
	private double steerSpeedFR = 0;
	private double steerSpeedBR = 0;
	private double steerSpeedBL = 0;

	public TeleopDrive() {
		// Use requires() here to declare subsystem dependencies
		// eg. requires(chassis);

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		wheelFL = new Vector(0, 1);
		wheelFR = new Vector(0, 1);
		wheelBR = new Vector(0, 1);
		wheelBL = new Vector(0, 1);
		driveStick = new Vector(0, 0);
		RobotMap.drivetrainSteerEncoderFL.reset();
		RobotMap.drivetrainSteerEncoderFR.reset();
		RobotMap.drivetrainSteerEncoderBL.reset();
		RobotMap.drivetrainSteerEncoderBR.reset();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		// All values must be greater than deadzone or they will be set to zero
		driveX = Math.abs(Robot.oi.getDriveJoystick().getX()) < deadzone ? 0 : 1 * Robot.oi
				.getDriveJoystick().getX();
		driveY = Math.abs(Robot.oi.getDriveJoystick().getY()) < deadzone ? 0 : -1 * Robot.oi
				.getDriveJoystick().getY();
		rotateX = Math.abs(Robot.oi.getStick2().getX()) < deadzone ? 0 : -Robot.oi
				.getStick2().getX();
		
		SmartDashboard.putNumber("driveX", driveX);
		SmartDashboard.putNumber("driveY", driveY);
		SmartDashboard.putNumber("rotateX", rotateX);
		driveStick.setXY(driveX, driveY);
		SmartDashboard.putNumber("Stick Angle", driveStick.getAngleDeg());
		driveStick.addAngle(RobotMap.imu.getYaw());
		if (rotateX == 0) {
			wheelFL.setXY(0, 0);
			wheelFR.setXY(0, 0);
			wheelBR.setXY(0, 0);
			wheelBL.setXY(0, 0);
			wheelFL.add(driveStick);
			wheelFR.add(driveStick);
			wheelBR.add(driveStick);
			wheelBL.add(driveStick);
		} else {
			wheelFL.setXY(-rotateX, rotateX);
			wheelFR.setXY(rotateX, rotateX);
			wheelBR.setXY(rotateX, -rotateX);
			wheelBL.setXY(-rotateX, -rotateX);
			wheelFL.add(driveStick);
			wheelFR.add(driveStick);
			wheelBR.add(driveStick);
			wheelBL.add(driveStick);
		}
		// set drive motor speed
		
		SmartDashboard.putNumber("DriveFL Speed", RobotMap.drivetrainDriveMotorFL.get());
		SmartDashboard.putNumber("DriveFR Speed", RobotMap.drivetrainDriveMotorFR.get());
		SmartDashboard.putNumber("DriveBR Speed", RobotMap.drivetrainDriveMotorBR.get());
		SmartDashboard.putNumber("DriveBL Speed", RobotMap.drivetrainDriveMotorBL.get());
		// set steer motors
		angleFL = (RobotMap.drivetrainSteerEncoderFL.getDistance()/1.2 % 360.0)
				- OFFSETSTEERENCODERFL;
		angleFR = (RobotMap.drivetrainSteerEncoderFR.getDistance()/1.2 % 360.0)
				- OFFSETSTEERENCODERFR;
		angleBR = (RobotMap.drivetrainSteerEncoderBR.getDistance()/1.2 % 360.0)
				- OFFSETSTEERENCODERBR;
		angleBL = (RobotMap.drivetrainSteerEncoderBL.getDistance()/1.2 % 360.0)
				- OFFSETSTEERENCODERBL;
		
		inverseFL = false;
		if(wheelFL.getAngleDeg()%180 == wheelFL.getAngleDeg())
			inverseFL = true;
		inverseFR = false;
		if(wheelFR.getAngleDeg()%180 == wheelFR.getAngleDeg())
			inverseFR = true;
		inverseBL = false;
		if(wheelBL.getAngleDeg()%180 == wheelBL.getAngleDeg())
			inverseBL = true;
		inverseBR = false;
		if(wheelBR.getAngleDeg()%180 == wheelBR.getAngleDeg())
			inverseBR = true;
		
		if((int)wheelFL.getAngleDeg()%180 == 0)
			inverseFL = !inverseFL;
		if((int)wheelFR.getAngleDeg()%180 == 0)
			inverseFR = !inverseFR;
		if((int)wheelBL.getAngleDeg()%180 == 0)
			inverseBL = !inverseBL;
		if((int)wheelBR.getAngleDeg()%180 == 0)
			inverseBR = !inverseBR;
		
//		if((int)wheelFL.getAngleDeg()%180 == 90)
//			inverseFL = !inverseFL;
//		if((int)wheelFR.getAngleDeg()%180 == 90)
//			inverseFR = !inverseFR;
//		if((int)wheelBL.getAngleDeg()%180 == 90)
//			inverseBL = !inverseBL;
//		if((int)wheelBR.getAngleDeg()%180 == 90)
//			inverseBR = !inverseBR;
		
		if(Math.abs(wheelFL.getAngleDeg()%180 - angleFL) > Math.abs(wheelFL.getAngleDeg()%180 - 360)- angleFL){
			steerSpeedFL = -STEERSPEEDCOEFFICIENT
					* ((wheelFL.getAngleDeg()%180 - 360)- angleFL);
		}else{
			steerSpeedFL = -STEERSPEEDCOEFFICIENT
					* (wheelFL.getAngleDeg()%180 - angleFL);
		}
		if(Math.abs(wheelFR.getAngleDeg()%180 - angleFR) > Math.abs((wheelFR.getAngleDeg()%180 - 360)- angleFR)){
			steerSpeedFR = -STEERSPEEDCOEFFICIENT
					* ((wheelFR.getAngleDeg()%180 - 360)- angleFR);
		}else{
			steerSpeedFR = -STEERSPEEDCOEFFICIENT
					* (wheelFR.getAngleDeg()%180 - angleFR);
		}
		if(Math.abs(wheelBR.getAngleDeg()%180 - angleBR) > Math.abs(wheelBR.getAngleDeg()%180 - 360)- angleBR){
			steerSpeedBR = -STEERSPEEDCOEFFICIENT
					* ((wheelBR.getAngleDeg()%180 - 360)- angleBR);
		}else{
			steerSpeedBR = -STEERSPEEDCOEFFICIENT
					* (wheelBR.getAngleDeg()%180 - angleBR);
		}
		if(Math.abs(wheelBL.getAngleDeg()%180 - angleBL) > Math.abs(wheelBL.getAngleDeg()%180 - 360)- angleBL){
			steerSpeedBL = -STEERSPEEDCOEFFICIENT
					* ((wheelBL.getAngleDeg()%180 - 360)- angleBL);
		}else{
			steerSpeedBL = -STEERSPEEDCOEFFICIENT
					* (wheelBL.getAngleDeg()%180 - angleBL);
		}
		
		if(Math.abs(steerSpeedFL) < 0.01){
			steerSpeedFL = 0;
		}else if(Math.abs(steerSpeedFL) < 0.1){
			steerSpeedFL = steerSpeedFL*0.15/(Math.abs(steerSpeedFL));
		}else{
			steerSpeedFL = steerSpeedFL*1.0/(Math.abs(steerSpeedFL));
		}
		
		if(Math.abs(steerSpeedFR) < 0.01){
			steerSpeedFR = 0;
		}else if(Math.abs(steerSpeedFR) < 0.1){
			steerSpeedFR = steerSpeedFR*0.15/(Math.abs(steerSpeedFR));
		}else{
			steerSpeedFR = steerSpeedFR*1.0/(Math.abs(steerSpeedFR));
		}
		
		if(Math.abs(steerSpeedBR) < 0.01){
			steerSpeedBR = 0;
		}else if(Math.abs(steerSpeedBR) < 0.1){
			steerSpeedBR = steerSpeedBR*0.15/(Math.abs(steerSpeedBR));
		}else{
			steerSpeedBR = steerSpeedBR*1.0/(Math.abs(steerSpeedBR));
		}
		
		if(Math.abs(steerSpeedBL) < 0.01){
			steerSpeedBL = 0;
		}else if(Math.abs(steerSpeedBL) < 0.1){
			steerSpeedBL = steerSpeedBL*0.15/(Math.abs(steerSpeedBL));
		}else{
			steerSpeedBL = steerSpeedBL*1.0/(Math.abs(steerSpeedBL));
		}
		
		SmartDashboard.putNumber("FL Angle", angleFL);
		SmartDashboard.putNumber("FR Angle", angleFR);
		SmartDashboard.putNumber("BR Angle", angleBR);
		SmartDashboard.putNumber("BL Angle", angleBL);
		
		SmartDashboard.putNumber("FL Wanted Angle", wheelFL.getAngleDeg());
		SmartDashboard.putNumber("FR Wanted Angle", wheelFR.getAngleDeg());
		SmartDashboard.putNumber("BR Wanted Angle", wheelBR.getAngleDeg());
		SmartDashboard.putNumber("BL Wanted Angle", wheelBL.getAngleDeg());

		RobotMap.drivetrainSteerMotorFL.set(steerSpeedFL > 1 ? 1
				: steerSpeedFL < -1 ? -1 : steerSpeedFL);
		RobotMap.drivetrainSteerMotorFR.set(steerSpeedFR > 1 ? 1
				: steerSpeedFR < -1 ? -1 : steerSpeedFR);
		RobotMap.drivetrainSteerMotorBR.set(steerSpeedBR > 1 ? 1
				: steerSpeedBR < -1 ? -1 : steerSpeedBR);
		RobotMap.drivetrainSteerMotorBL.set(steerSpeedBL > 1 ? 1
				: steerSpeedBL < -1 ? -1 : steerSpeedBL);
		
		SmartDashboard.putNumber("SteerFL Speed", steerSpeedFL);
		SmartDashboard.putNumber("SteerFR Speed", steerSpeedFR);
		SmartDashboard.putNumber("SteerBR Speed", steerSpeedBR);
		SmartDashboard.putNumber("SteerBL Speed", steerSpeedBL);
		
		if(Math.abs(steerSpeedFL) + Math.abs(steerSpeedFR) + Math.abs(steerSpeedBR) + Math.abs(steerSpeedBL) <= 0.6){
			RobotMap.drivetrainDriveMotorFL.set(inverseFL ? -wheelFL.getH() : wheelFL.getH());
			RobotMap.drivetrainDriveMotorFR.set(inverseFR ? wheelFR.getH() : -wheelFR.getH());
			RobotMap.drivetrainDriveMotorBR.set(inverseBR ? wheelBR.getH() : -wheelBR.getH());
			RobotMap.drivetrainDriveMotorBL.set(inverseBL ? -wheelBL.getH() : wheelBL.getH());
			}else{
				RobotMap.drivetrainDriveMotorFL.set(0);
				RobotMap.drivetrainDriveMotorFR.set(0);
				RobotMap.drivetrainDriveMotorBR.set(0);
				RobotMap.drivetrainDriveMotorBL.set(0);
			}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}
}
